// Welcome to JavaScript Collections!
const sections = ["introduction", "array", "set"];
const paragraphs = [];
var template = document.getElementById("template");
debugger
const resources = [
  {
    site: "https://javascript.info/array-methods",
    description: "Array Methods"
  },
  {
    site: "https://developer.mozilla.org/en-US/",
    description:
      "MDN Network. Very useful to google 'mdn <topic>' (your mileage may vary depending on <topic>)"
  }
];
let slideId = 0;

//show slide

function showNext(back) {
  if (back && slideId > 0) slideId = slideId - 2;

  if (slideId > sections.length || slideId < 0) slideId = 0;

  template.innerHTML = null;
  //I wanted to call the section methods dynamically
  //but couldn't figure it out in codepen
  switch (sections[slideId]) {
    case "introduction":
      introduction();
      break;
    case "array":
      array();
      break;
    default:
      break;
  }
  //Create the section headings
  sections.forEach((val) => {
    let h2 = createElement("h2");

    h2.id = "section-" + val;

    if (val === sections[slideId]) {
      let em = createElement("em", h2);
      em.innerText = val;
    } else h2.innerText = val;
    template.appendChild(h2);
  });
  if (!back) slideId++;
}
/* Presentation Start
 ******/
//////
/////
////
///
//
//introduction
//
function introduction() {
  let p = addParagraph(
    "Welcome to the JavaScript collections presentation. I'll walk \
    through some of the methods that make working with them more easy."
  );
}
//
//array
//
function array() {
  let container = createElement("div", template);

  let intro =
    "An array is a collection of stuff in JavaScript. Typically \
denoted as [1,2,4] with a square bracket at the beginning and end, and with the \
values separated by commas. Arrays are not typed by default and contain varying types \
of data. It is fine to mix numbers, strings, and objects. [1,'two', {num:3}]";
  addParagraph(intro, container);
  let pushPop = addParagraph(
    "The methods 'push' and 'pop' allow you to add and remove items \
from the end of the array",
    container
  );
  //illustrating the order in which items are added via push
  let methods = [];
  methods.push(...["push", "pop", "extra"]);
  let ul = createElement("ul", pushPop);

  addRemoveItems(ul, methods, container);
  // the end of the clickthrough of the above method takes us
  // to other array methods
  //
  //
  //
  //////
  ////
  //
}
function arrayMethods(container) {
  //We're going to cover the following methods
  const methods = ["forEach", "slice", "filter", "map"];
  addParagraph(
    "The next group of methods are the the ones I use the most during the day. \
    Most are looping methods that allow work to be done per item in the array. \
    Some create new arrays to protect the original, and others can affect the current array.",
    container
  );
  addList(methods, "methods", container, () => {});
  //
  //
  //.........>forEach<.........
  //
  //
  //in real life have a function that builds the id and use it to create and access the element.
  let forEachI = document.getElementById("methodsforEach_id");

  //We can see below in the addList above that foreach loops through each item
  //and does an action with the item available to do your biddin
  forEachI.addEventListener(
    "click",
    () => {
      let forEachP = addParagraph(
        "The method forEach() does work (executes a passed in function) for each item \
         in the array and has access to the current item, the index of that item, and the \
         array itself. Modifying the array as you loop through it can have unintended consequences.\
         The list of methods above was generated by looping through an array of method names via array.forEach(). ",
        container
      );
      let linkFE = createElement("a", forEachP);
      linkFE.href =
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach";
      linkFE.target = "_blank";
      linkFE.innerText =
        "MDN: methods.forEach(item,index,array) => {... some work ...}";
    },
    { once: true }
  );
  /* ..>S
.......>L
.......>I
.......>C
.......>E */

  let sliceI = document.getElementById("methodsslice_id");
  sliceI.addEventListener(
    "click",
    () => {
      let sliceP = addParagraph(
        "The method slice(start, end) creates a shallow copy of an array with \
         the first item being at the start index, and ending with the item \
         before the end index. To create a list with just the 'slice' item, \
         we would say methods.slice(1,2); This would give us all the items after \
         the first, and before the third. ",
        container,
        () =>
          addParagraph(
            "Be careful with object arrays, as changes to the individual objects are persisted. ",
            sliceP
          )
      );
      let sliceL = createElement("a", sliceP);
      sliceL.href =
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice";
      sliceL.target = "_blank";
      sliceL.innerText = "MDN: let otherArray = methods.slice(start,end)";
      //We can create a new list with just "slice" in it that doesn't
      //effect the original list.
      let justSlice = methods.slice(1, 2);
      addList(justSlice, "slice", container);
    },
    { once: true }
  );
  /************* FILTER
   ************/
  /**********
   *******/
  //Resources are made of an object with a site and a description.
  //{ site: <url>, description: <text> }
  let newResources = resources.slice();
  newResources.push({ site: "", description: "Invalid Item" });
  let filterI = document.getElementById("methodsfilter_id");
  filterI.addEventListener(
    "click",
    () => {
      let filterP = addParagraph(
        "filter() calls the function provided to it once per item in the array. It returns \
        a new array of the items that are returned by the function passed in.",
        container
      );
      let codePenFilterL = createElement("a", filterP);
      codePenFilterL.href = "https://codepen.io/polychlorobenzene/pen/MWpqxbY";
      codePenFilterL.target = "_blank";
      codePenFilterL.innerText =
        "CodePen example using a filter. Not exciting, just a test for a project.";
      codePenFilterL.classList.add("block");
      let filterL = createElement("a", filterP);
      filterL.href =
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter";
      filterL.target = "_blank";
      filterL.innerText =
        "let otherArray = methods.filter(item,index,array) => item === 'filter'";
      filterL.classList.add("block");
      //If we wanted to add a list with only the filter method in it we can do it with slice
      let justFilter = methods.slice(2, 3); //This is very brittle. If the array is unshifted
      //or something else happens to the index of 'filter' the method could return the 'wrong'
      //element depending on the application
      justFilter = methods.filter((val) => val === "filter");
      addList(justFilter, "justFilter", container);

      //Preview: map to just get the list of descriptions.
      console.log(
        `site list: ${newResources.map(
          (obj) => obj.site
        )}, description: ${newResources.map((obj) => obj.description)}`
      );
      let res = resources.filter((obj) => {
        if (obj.site && obj.site !== "") return obj;
      });
      //Filter creates a new array
      //with only the items in it that are returned from the evaluation function
      console.log(
        `Original: site list: ${newResources.map(
          (obj) => obj.site
        )}, description: ${newResources.map((obj) => obj.description)}`
      );
      console.log(
        `Filtered: site list: ${res.map(
          (obj) => obj.site
        )}, description: ${res.map((obj) => obj.description)}`
      );
    },
    { once: true }
  );

  let mapI = document.getElementById("methodsmap_id");
  mapI.addEventListener(
    "click",
    () => {
      let mapP = addParagraph(
        "The method map() creates a new array made up of the items returned by the passed in function \
        for each of the items in the array. It has access to the item, it's index, and the original array. ",
        container
      );
      let mapL = createElement("a", mapP);
      mapL.href =
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map";
      mapL.target = "_blank";
      mapL.innerText =
        "MDN: let otherArray = methods.map(item, index, array)=> {...return something}";
      //We'll use map to build some resources and add them to the resources list
      if (newResources.length > 2) newResources.pop(); //get rid of the invalid one
      newResources.push(
        ...methods.map((item, index, array) => {
          let url = `https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/${item}`;
          let description = `Description of the method ${item} in position[${index}]`;
          return { site: url, description: description };
        })
      );
      showResources(newResources);
    },
    { once: true }
  );
}
//End arrayMethods

//terrible function. It bleeds responsibility everywhere
function addRemoveItems(ul, array, container) {
  let isShift = false;
  ul.innerHTML = null;
  if (array.length === 0) {
    // alert("zero length")
    let p = document.getElementById("shift-paragraph");
    if (!p) {
      array.unshift(...["unshift", "shift", "extra"]);
      p = addParagraph(
        "shift and unshift work similarly, but take and \
add items from the front of the array",
        container
      );
      p.id = "shift-paragraph";
    } else {
      p = addParagraph(
        "That concludes the simple methods for adding \
and removing single items from an array.",
        container,
        () => {
          container.innerHTML = null;
          arrayMethods(container);
        }
      );
    }
  }
  isShift = array.some((val) => val === "shift");
  array.forEach((method) => {
    let li = createElement("li", ul);
    if (isShift) {
      li.addEventListener(
        "click",
        () => {
          array.shift();
          addRemoveItems(ul, array, container);
        },
        false
      );
    } else
      li.addEventListener(
        "click",
        () => {
          array.pop();
          addRemoveItems(ul, array, container);
        },
        false
      );
    li.innerText = method;
    ul.appendChild(li);
    //pause(2000); //TODO: make pausing work
  });
}
async function pause(duration) {
  //alert("pause")
  await sleep(duration);
}
//resources
showResources(resources);
//resources.push({site:"https://www.google.com", description: "Google, always there. Mostly."})
//addResources(resources)

function showResources(array) {
  let div = document.getElementById("resources");
  if (div) div.remove();
  div = createElement("div");
  div.id = "resources";
  template.parentNode.insertBefore(div, template.nextSibling);

  div.innerHtml = null;
  let h2 = createElement("h2", div);
  h2.innerText = "resources";
  const resourceList = createElement("ul", div);
  array.forEach((obj) => {
    let li = createElement("li", resourceList);
    let res = createElement("span", li);
    let desc = createElement("span", li);
    let link = createElement("a", res);
    link.href = obj.site;
    link.target = "_blank";
    link.innerText = obj.site;
    desc.innerText = obj.description + " : ";
    resourceList.appendChild(desc);
    resourceList.appendChild(res);
  });
  //template.appendChild(resourceList);
}
function createElement(type, parent) {
  let el = document.createElement(type);
  if (parent) parent.appendChild(el);
  return el;
}
function addParagraph(text, parent, listener, options) {
  const once = {
    once: true
  };
  let p = createElement("p", parent ? parent : template);
  p.innerText = text;
  p.id = `${slideId}_p${paragraphs.length}`;
  paragraphs.push(p);

  if (listener) p.addEventListener("click", listener, options ? once : options);
  return p;
}
//addList(["One", "Two", "Three"].slice(1, 2), "initial", template);
function addList(array, listName, container, listener, options) {
  let ul = document.getElementById(listName);
  let workingArray = array.slice();
  if (!ul) {
    ul = createElement("ul", container);
    ul.id = listName;
    ul.innerText = `${listName} list`;
    ul.addEventListener(
      "click",
      () => {
        if (workingArray.length === 0) {
          addList(array, listName, container, listener);
        }
      },
      options ? { once: true } : options
    );
  }
  workingArray.forEach((item) => {
    let li = createElement("li", ul);
    li.innerText = item;
    ul.appendChild(li);
    li.id = `${listName}${item}_id`;
    li.addEventListener(
      "click",
      listener
        ? listener
        : (e) => {
            e.stopPropagation();
            workingArray.pop();
            let me = document.getElementById(`${listName}${item}_id`);
            me.remove();
          },
      { capture: true, once: true }
    );
  });
  return ul;
}
const next = document.getElementById("next");
next.addEventListener(
  "click",
  () => {
    showNext();
  },
  false
);
const back = document.getElementById("back");
back.addEventListener(
  "click",
  () => {
    showNext(true);
  },
  false
);
//Features: add back button, show code as display, styling

/*********** E N D *********************

****************************************/
// RIP shovel (autoformat)
// ___\\
//
//
//
//
//
//
//------\\
//      \\
//      \\
//    \\
//  \\
//

//They bitch about minimum wage and the expense of providing healthcare for the workers. If the government actually provided helthcare and housing, it would be much easier to live and take odd jobs when they were wanted. Someone could offer minimum wage easier because they would not have to worry about healthcare, and the recipient could accept it as a bonus when received because the basics of life and health are taken care of. It would still incentivize wanting earning power, but not at the point of working to live.
//Time is invaluable. It would be a much more humane world if we could go to a piecemeal system that was fair. Some sort of middle of the bell curve set of tasks that promote optimization without taking advantage. If, given all the data of tasks for a given outcome, the set of tasks or items that would take a reasonably motivated person 4 hours. That would allow either the fastest route to get to the specification of done, or they could take their time, when needed, to take enough time to build in quality and resilience. No minimum time. If the set of tasks expected of you can be automated, that is your time.
